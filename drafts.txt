
async def all_schedule():
    logger.debug("getting all schedule")

    try:
        # open session to database
        async with await db.get_session() as session:
            async with session.begin():
                query = (
                        db.select(
                            db.table.Lessons.item, 
                            db.table.Lessons.num_day, 
                            db.table.Lessons.num_lesson, 
                            db.table.Lessons.week, 
                            db.table.Lessons.teacher, 
                            db.table.Lessons.cabinet, 
                    )
                    .order_by(db.table.Lessons.group.asc(), db.table.Lessons.num_day.asc(), db.table.Lessons.num_lesson.asc())                 
                )

                result = await session.execute(query)
                all_lessons = result.scalars().all()


                query_time = (
                    db.select(
                        db.table.Times.time, 
                        db.table.Times.num_lesson, 
                        db.table.Times.num_day
                    )
                    .order_by(db.table.Times.num_day.asc(), db.table.Times.num_lesson.asc())                 
                )

                result_time = await session.execute(query_time)
                time_data = result_time.all()

                time_key = {}
                for i in time_data:
                    time_key[(i.num_day, i.num_lesson)] = i.time.split(', ')

                result_all_groups_schedule = []

                for lesson in all_lessons:
                    # Generate schedule
                    final_schedule = []

                    schedule_info = {
                        "group": lesson.group,
                        "week": lesson.num_week,
                        "schedule": final_schedule
                    }

                # If schedule does not exist, return false
                if not schedule_data:
                    logger.info(f"schedule not in database for group: {group}")

                    await rabbitmq.response_in_queue_schedule(json.dumps(schedule_info), reply_to)
                    return False

                # Group lessons by days
                grouped_schedule = {}
                for lesson in schedule_data:
                    if lesson.num_day not in grouped_schedule:
                        grouped_schedule[lesson.num_day] = []
                    grouped_schedule[lesson.num_day].append(lesson)

                try:
                    # Sort schedule data by current day
                    sorted_days = sorted(grouped_schedule.keys())
                    index = sorted_days.index(num_day)
                    sorted_schedule_keys = sorted_days[index:] + sorted_days[:index]
                except Exception:
                    sorted_schedule_keys = sorted_days

                status_time = True

                for day in sorted_schedule_keys:
                    lessons = grouped_schedule[day]

                    lessons_in_schedule = []

                    for lesson in lessons:
                        try:
                            event_time = time_key[(lesson.num_day, lesson.num_lesson)]

                            if lesson.num_day is num_day:
                                status, time = await time_utils.check_time_lessons(event_time)
                            else:
                                status, time = False, ""

                        except KeyError:
                            event_time = [""]
                            status, time = False, ""


                        lessons_in_schedule.append({
                                        "item": lesson.item,
                                        "cabinet": lesson.cabinet,
                                        "teacher": lesson.teacher,
                                        "event_time": event_time,
                                        "status": status if status_time else None,
                                        "time": time
                                    })
                        if status:
                            status_time = False
                        

                    schedule = {
                                "day": models.Num_day[day] + " (Сегодня)" if num_day == day else models.Num_day[day],
                                "date": await time_utils.get_date_by_day(day),
                                "lessons": lessons_in_schedule
                            }
                    final_schedule.append(schedule)


                    


    except Exception:
        logger.exception("error getting all schedule")
        return False
    